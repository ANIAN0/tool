# 第2期开发进展

## 概述
**目标**：实现多Agent切换功能，支持"正式Agent"和"开发Agent"的切换

**开始日期**：2026-02-21

---

## 功能点进展

### 功能点1：Agent配置与类型定义 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `lib/agents/config.ts`（新建）

**实现内容**：
1. 定义 `AgentConfig` 接口，包含 id、name、description、systemPrompt 属性
2. 创建 `AGENTS` 配置数组，包含正式Agent和开发Agent
3. 实现 `getAgentConfig()` 函数，根据 ID 获取配置
4. 实现 `getAgentList()` 函数，获取用于前端展示的 Agent 列表
5. 实现 `isValidAgentId()` 函数，验证 Agent ID 是否有效

**验收结果**：
- ✅ 类型定义完整
- ✅ 默认配置包含两个Agent
- ✅ 提供获取Agent配置的工具函数
- ✅ 类型检查通过
- ✅ 功能测试通过

---

### 功能点2：数据库Schema修改 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `lib/db/schema.ts`（修改）
- `lib/db/index.ts`（修改）
- `scripts/migrate-db.ts`（新建）

**实现内容**：
1. 在 `CREATE_CONVERSATIONS_TABLE` 中添加 `agent_id TEXT DEFAULT 'production'` 字段
2. 添加 `MIGRATION_ADD_AGENT_ID` 迁移SQL语句
3. 更新 `Conversation` 接口，添加 `agent_id` 字段
4. 更新 `CreateConversationParams` 接口，添加 `agentId` 参数
5. 创建迁移脚本 `migrate-db.ts`，支持安全地添加新字段

**验收结果**：
- ✅ Schema定义更新
- ✅ 类型定义更新
- ✅ 迁移脚本执行成功
- ✅ 现有对话默认使用正式Agent

---

### 功能点3：对话数据访问层修改 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `lib/db/conversations.ts`（修改）

**实现内容**：
1. 导入 `DEFAULT_AGENT_ID` 常量
2. 修改 `rowToConversation` 函数，添加 `agent_id` 字段处理
3. 修改 `createConversation` 函数：
   - SQL语句添加 `agent_id` 字段
   - 参数添加 `agentId` 支持，默认使用正式Agent
   - 返回值添加 `agent_id` 字段

**验收结果**：
- ✅ 创建对话时记录 agent_id
- ✅ 查询对话时返回 agent_id
- ✅ 类型检查通过

---

### 功能点4：修改聊天API支持Agent切换 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `app/api/chat/route.ts`（修改）

**实现内容**：
1. 导入 `getAgentConfig` 和 `DEFAULT_AGENT_ID` 常量
2. 更新请求解析，添加 `agentId` 参数支持
3. 修改系统提示词获取逻辑，根据Agent ID动态获取
4. 更新对话创建逻辑，保存Agent ID到数据库
5. 优化对话验证逻辑，确保对话关联的Agent信息正确

**验收结果**：
- ✅ API支持agentId参数
- ✅ 默认使用正式Agent
- ✅ 正确加载对应的系统提示词
- ✅ 创建对话时记录agent_id
- ✅ 类型检查通过

---

### 功能点5：Agent选择器组件 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `components/chat/agent-selector.tsx`（新建）

**实现内容**：
1. 使用AI Elements的复合组件模式构建
2. 基于ModelSelector实现，复用其对话框结构
3. 显示当前选中Agent的图标和名称
4. 支持搜索和分组显示
5. 实现Agent变更回调

**验收结果**：
- ✅ 选择器正常工作
- ✅ 选中状态正确显示
- ✅ 支持搜索功能
- ✅ 样式与ModelSelector一致
- ✅ 类型检查通过

---

### 功能点6：对话页面集成Agent选择器 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `app/chat/page.tsx`（修改）

**实现内容**：
1. 导入 `AgentSelector` 组件和 `DEFAULT_AGENT_ID` 常量
2. 添加 `selectedAgentId` 状态管理选中的Agent
3. 添加 `useRef` 存储 Agent ID，确保每次请求都使用最新值
4. 添加effect，当切换对话时，自动更新选中的Agent
5. 在页面header部分添加Agent选择器组件
6. **历史对话时禁用Agent选择器**：显示当前Agent但不允许修改
7. 添加console.log调试信息便于排查问题

**验收结果**：
- ✅ Agent选择器正确显示
- ✅ 切换对话时自动切换到对话关联的Agent
- ✅ 新建对话使用当前选择的Agent
- ✅ 发送消息时正确传递agentId
- ✅ 历史对话时Agent选择器禁用但显示当前Agent
- ✅ 使用useRef确保状态同步

---

## 开发问题与解决

### 问题1：Agent切换不生效
**现象**：用户切换到开发Agent后，发送消息仍使用正式Agent

**原因**：`selectedAgentId` 状态没有正确传递到API请求中，`useMemo` 依赖项导致使用闭包中的旧值

**解决**：使用 `useRef` 存储最新的 `agentId`，在 `body` 函数中读取 ref 的当前值

### 问题2：历史对话看不到Agent选择器
**现象**：点击历史对话后，Agent选择器消失

**原因**：错误地在 `currentConversationId` 存在时隐藏了 Agent 选择器

**解决**：始终显示 Agent 选择器，但在历史对话时设置为禁用状态

---

## 总结

### 第2期开发完成情况

**完成日期**：2026-02-21

**功能点完成情况**：
- ✅ 功能点1：Agent配置与类型定义
- ✅ 功能点2：数据库Schema修改
- ✅ 功能点3：对话数据访问层修改
- ✅ 功能点4：修改聊天API支持Agent切换
- ✅ 功能点5：Agent选择器组件
- ✅ 功能点6：对话页面集成Agent选择器

**总体进度**：6/6 (100%)

### 主要技术实现

1. **配置管理**：创建 `lib/agents/config.ts`，统一管理多个Agent的配置
2. **数据存储**：数据库添加 `agent_id` 字段，支持对话关联Agent
3. **API改造**：根据Agent ID动态加载系统提示词
4. **状态管理**：使用 `useRef` 确保状态同步
5. **UI设计**：历史对话时禁用Agent选择器但显示当前Agent

### 关键决策

- 使用代码配置而非数据库存储，便于快速开发和部署
- 实现对话独立Agent，符合产品设计原则
- Agent选择器始终可见，提供更好的用户体验
- 使用useRef确保状态同步，避免闭包问题

| 模块 | 进度 |
|------|------|
| 配置与类型 | 1/1 ✅ |
| 数据存储 | 2/2 ✅ |
| 后端API | 1/1 ✅ |
| 前端组件 | 1/1 ✅ |
| 页面集成 | 1/1 ✅ |
| **总计** | **6/6 (100%)** |

---

# 第3期开发进展

## 概述
**目标**：为不同Agent配置不同的工具，实现正式Agent和开发Agent的工具隔离

**开始日期**：2026-02-21

---

## 功能点进展

### 功能点1：安装依赖并配置环境变量 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `package.json`（修改）
- `.env`（修改）

**实现内容**：
1. 安装 `@modelcontextprotocol/sdk` 依赖包
2. 验证 `bash-tool` 和 `@tavily/ai-sdk` 已安装
3. 在 `.env` 文件中添加 `TAVILY_API_KEY` 配置项

**验收结果**：
- ✅ 依赖包安装成功
- ✅ 环境变量配置已添加
- ✅ package.json 更新完成

---

### 功能点2：修改Agent配置接口 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `lib/agents/config.ts`（修改）

**实现内容**：
1. 在 `AgentConfig` 接口中添加 `tools?: Array<'bash' | 'tavily' | 'mcp'>` 可选字段
2. 为正式Agent配置 `tools: ['bash']`
3. 为开发Agent配置 `tools: ['bash', 'tavily', 'mcp']`

**验收结果**：
- ✅ 类型定义更新完成
- ✅ 正式Agent仅配置bash工具
- ✅ 开发Agent配置全部工具
- ✅ 类型检查通过

---

### 功能点3：创建工具配置模块 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `lib/agents/tools.ts`（新建）

**实现内容**：
1. 定义 `ToolType` 类型：`'bash' | 'tavily' | 'mcp'`
2. 实现 `createBashTools()` 函数，创建bash工具
3. 实现 `createTavilyTools()` 函数，创建tavily搜索工具
4. 实现 `createLangChainMCPTools()` 函数（占位实现，MCP需要服务端配置）
5. 实现 `createToolsByTypes()` 函数，根据工具类型列表创建工具对象
6. 导出 `AGENT_TOOLS_CONFIG` 预定义配置
7. 实现 `getAgentToolsConfig()` 和 `getAgentToolsDescription()` 辅助函数

**验收结果**：
- ✅ 工具配置模块创建完成
- ✅ 支持动态创建不同工具
- ✅ 类型检查通过（使用ToolSet类型）

---

### 功能点4：修改聊天API支持工具 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `app/api/chat/route.ts`（修改）

**实现内容**：
1. 导入 `createToolsByTypes` 函数
2. 根据Agent配置调用 `createToolsByTypes()` 创建工具
3. 在 `streamText()` 调用中添加 `tools` 参数
4. 添加空工具判断，避免传递undefined

**验收结果**：
- ✅ API根据agentId加载对应工具
- ✅ 正式Agent使用bash工具
- ✅ 开发Agent使用所有可用工具
- ✅ 类型检查通过
- ✅ lint检查通过（过滤ai-elements警告）

---

## 开发问题与解决

### 问题1：MCP工具配置复杂
**现象**：MCP工具需要服务端配置，无法直接在Next.js API路由中使用

**原因**：MCP需要客户端进程或WebSocket连接，不适用于无服务器的API路由

**解决**：实现占位配置，返回空对象并输出警告日志，未来可以通过单独的服务进程提供MCP支持

### 问题2：类型定义不匹配
**现象**：`Record<string, unknown>` 无法赋值给 `ToolSet` 类型

**原因**：ToolSet是特定类型的工具集合，需要使用正确的泛型类型

**解决**：修改返回类型为 `ToolSet`，导入 `Tool` 和 `ToolSet` 类型

### 问题3：MCP工具实现不正确
**现象**：使用占位实现，没有实际连接到MCP服务器

**原因**：错误地认为MCP需要服务端配置，实际上LangChain提供了公共MCP服务器

**解决**：
1. 安装 `@ai-sdk/mcp` 包
2. 使用 `createMCPClient` 创建客户端
3. 通过HTTP传输连接到 `https://docs.langchain.com/mcp`
4. 调用 `mcpClient.tools()` 获取工具
5. 使用后关闭客户端连接

---

## 总结

### 第3期开发完成情况

**完成日期**：2026-02-21

**功能点完成情况**：
- ✅ 功能点1：安装依赖并配置环境变量
- ✅ 功能点2：修改Agent配置接口
- ✅ 功能点3：创建工具配置模块
- ✅ 功能点4：修改聊天API支持工具

**总体进度**：4/4 (100%)

### 主要技术实现

1. **工具管理**：创建 `lib/agents/tools.ts`，统一管理工具创建逻辑
2. **类型安全**：使用 `ToolSet` 类型确保工具类型正确
3. **动态加载**：根据Agent配置动态创建对应的工具集合
4. **环境配置**：添加Tavily API密钥配置支持

### 功能验证

| Agent | 工具配置 | 说明 |
|-------|----------|------|
| 正式Agent | bash | 仅提供bash命令执行能力 |
| 开发Agent | bash + tavily + mcp | 提供完整的开发调试能力 |

### 注意事项

1. **MCP工具**：当前为占位实现，需要服务端配置才能正常工作
2. **API密钥**：Tavily需要有效的API密钥才能使用搜索功能
3. **安全性**：bash工具在服务端执行，需要确保环境安全

| 模块 | 进度 |
|------|------|
| 依赖安装 | 1/1 ✅ |
| 配置修改 | 1/1 ✅ |
| 工具模块 | 1/1 ✅ |
| API集成 | 1/1 ✅ |
| **第3期总计** | **4/4 (100%)** |

---

# 第3期修订：使用ToolLoopAgent重构

## 概述
**目标**：使用 `ToolLoopAgent` 替代 `streamText`，实现自动工具调用循环

**开始日期**：2026-02-21

**背景**：第3期初步实现后发现工具调用无法正常工作，原因是 `streamText` 需要手动处理多步骤调用，前端也需要处理 `parts` 显示工具调用。

---

## 功能点进展

### 功能点1：创建Agent工厂函数 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `lib/agents/index.ts`（新建）

**实现内容**：
1. 导入 `ToolLoopAgent` 和 `stepCountIs` 从 `ai` 包
2. 实现 `createAgent(agentId, model)` 工厂函数
3. 根据agentId加载配置，创建ToolLoopAgent实例
4. 设置停止条件 `stepCountIs(10)`
5. 导出类型和配置

**验收结果**：
- ✅ Agent工厂函数创建完成
- ✅ 正确加载系统提示词和工具
- ✅ 类型检查通过

---

### 功能点2：修改聊天API使用ToolLoopAgent ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `app/api/chat/route.ts`（重构）

**实现内容**：
1. 导入 `createAgent` 工厂函数
2. 使用 `createAgent()` 创建Agent实例
3. 使用 `agent.stream()` 替代 `streamText()`
4. 修改 `onFinish` 回调处理步骤信息
5. 返回流式响应 `toUIMessageStreamResponse()`

**验收结果**：
- ✅ API正确使用ToolLoopAgent
- ✅ 工具调用自动循环执行
- ✅ 类型检查通过

---

### 功能点3：修改前端消息显示 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `components/chat/tool-call-display.tsx`（新建）
- `app/chat/page.tsx`（修改）

**实现内容**：
1. 创建 `ToolCallDisplay` 组件，支持四种状态：
   - `input-streaming`：输入参数流式生成中
   - `input-available`：输入参数已完整，等待执行
   - `output-available`：工具执行成功
   - `output-error`：工具执行失败
2. 创建 `StepDivider` 组件显示步骤分隔线
3. 创建 `isToolCallPart()` 和 `isStepStartPart()` 类型判断函数
4. 修改消息渲染逻辑，支持显示工具调用和步骤

**验收结果**：
- ✅ 文本消息正确显示
- ✅ 工具调用正确显示（四种状态）
- ✅ 步骤分隔线正确显示
- ✅ 类型检查通过

---

### 功能点4：消息存储逻辑 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `lib/db/messages.ts`（无需修改）

**实现内容**：
- 保持简化方案：只存储最终text内容
- 工具调用细节由前端 `useChat` hook 管理
- `onFinish` 回调在所有步骤完成后调用，保存最终回复

**验收结果**：
- ✅ 消息正确存储到数据库
- ✅ 历史消息正确加载

---

## 开发问题与解决

### 问题：工具调用无法正常工作
**现象**：调用工具后，对话结束，没有获取工具结果，也没有AI回复

**原因**：
1. `streamText` 需要手动实现 `stopWhen` 多步骤调用
2. 前端消息组件没有处理 `parts` 属性

**解决**：
1. 使用 `ToolLoopAgent` 替代 `streamText`，自动处理工具调用循环
2. 创建 `ToolCallDisplay` 组件，支持显示工具调用和结果

---

## 总结

### 第3期修订开发完成情况

**完成日期**：2026-02-21

**功能点完成情况**：
- ✅ 功能点1：创建Agent工厂函数
- ✅ 功能点2：修改聊天API使用ToolLoopAgent
- ✅ 功能点3：修改前端消息显示
- ✅ 功能点4：消息存储逻辑

**总体进度**：4/4 (100%)

### 主要技术实现

1. **Agent工厂**：创建 `lib/agents/index.ts`，封装ToolLoopAgent创建逻辑
2. **自动循环**：ToolLoopAgent自动处理Reasoning-and-Acting循环
3. **工具显示**：创建专用组件显示工具调用的四种状态
4. **类型安全**：使用正确的类型定义确保类型检查通过

### 功能验证

| 功能 | 状态 |
|------|------|
| ToolLoopAgent创建 | ✅ |
| 工具调用循环 | ✅ |
| 工具调用显示 | ✅ |
| 工具结果显示 | ✅ |
| 步骤分隔显示 | ✅ |

### 消息类型支持

| Part类型 | 说明 | 状态 |
|----------|------|------|
| `text` | 文本内容 | ✅ |
| `tool-{toolName}` | 工具调用 | ✅ |
| `dynamic-tool` | 动态工具 | ✅ |
| `step-start` | 步骤开始 | ✅ |

| 模块 | 进度 |
|------|------|
| Agent工厂 | 1/1 ✅ |
| API重构 | 1/1 ✅ |
| 前端显示 | 2/2 ✅ |
| 消息存储 | 1/1 ✅ |
| **第3期修订总计** | **5/5 (100%)** |

---

# 第3期补充：消息存储方案实现

## 概述
**目标**：保存完整消息，包括工具调用过程

**开始日期**：2026-02-21

---

## 功能点进展

### 功能点1：修改schema.ts ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `lib/db/schema.ts`（修改）

**实现内容**：
1. 更新messages表注释，说明content字段可存储JSON
2. 添加MessagePart类型定义（与AI SDK UIMessage.parts兼容）
3. 添加FullMessage类型定义（与AI SDK UIMessage兼容）

**验收结果**：
- ✅ 类型定义更新完成

---

### 功能点2：修改前端消息解析 ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `app/chat/page.tsx`（修改）

**实现内容**：
1. 修改`dbMessageToUIMessage()`函数
2. 尝试解析content为JSON
3. 如果解析成功且包含完整结构，返回解析后的UIMessage
4. 如果解析失败，作为纯文本处理（兼容历史数据）

**验收结果**：
- ✅ 支持解析JSON格式
- ✅ 兼容纯文本格式（历史数据）

---

### 功能点3：修改API的onFinish ✅
**状态**：已完成
**完成日期**：2026-02-21

**涉及文件**：
- `app/api/chat/route.ts`（修改）

**实现内容**：
1. 添加`buildPartsFromSteps()`辅助函数
   - 从Agent的steps构建UIMessage parts
   - 处理文本内容、工具调用、步骤分隔符
   - 区分静态工具和动态工具
2. 修改onFinish回调
   - 构建完整的UIMessage结构
   - 保存为JSON字符串
3. 修改用户消息保存逻辑
   - 也保存完整的UIMessage结构

**验收结果**：
- ✅ 用户消息保存完整结构
- ✅ 助手消息保存完整结构（包括工具调用）
- ✅ 类型检查通过

---

## 总结

### 消息存储格式

**用户消息示例**：
```json
{
  "id": "msg_xxx",
  "role": "user",
  "parts": [{ "type": "text", "text": "用户输入的内容" }]
}
```

**助手消息示例（包含工具调用）**：
```json
{
  "id": "msg_yyy",
  "role": "assistant",
  "parts": [
    { "type": "text", "text": "让我帮你执行命令..." },
    { "type": "tool-bash", "toolCallId": "call_xxx", "input": {...}, "output": {...}, "state": "output-available" },
    { "type": "step-start" },
    { "type": "text", "text": "命令执行成功，结果是..." }
  ]
}
```

### 兼容性
- 历史数据（纯文本格式）仍然可以正常加载
- 新消息使用JSON格式存储完整结构

| 模块 | 进度 |
|------|------|
| Schema修改 | 1/1 ✅ |
| 前端解析 | 1/1 ✅ |
| API保存 | 1/1 ✅ |
| **第3期补充总计** | **3/3 (100%)** |

---

# 第3期补充2：工具生命周期管理

## 概述
**目标**：修复MCP工具调用报错 "Attempted to send a request from a closed client"

**开始日期**：2026-02-22

---

## 功能点进展

### 功能点1：修改tools.ts返回清理函数 ✅
**状态**：已完成
**完成日期**：2026-02-22

**涉及文件**：
- `lib/agents/tools.ts`（修改）

**实现内容**：
1. 导入 `MCPClient` 类型
2. 修改 `createLangChainMCPTools()` 返回 `{ tools, mcpClient }`
3. **不再关闭客户端**，由调用者负责关闭
4. 修改 `createToolsByTypes()` 返回 `{ tools, cleanup }`
5. 收集需要清理的资源（如MCP客户端）
6. 返回统一的清理函数

**验收结果**：
- ✅ MCP客户端不再提前关闭
- ✅ 返回清理函数供调用者使用
- ✅ 类型检查通过

---

### 功能点2：修改Agent工厂返回清理函数 ✅
**状态**：已完成
**完成日期**：2026-02-22

**涉及文件**：
- `lib/agents/index.ts`（修改）

**实现内容**：
1. 定义 `AgentCreateResult` 接口，包含 `agent` 和 `cleanup`
2. 修改 `createAgent()` 返回 `{ agent, cleanup }`
3. 导出 `ToolsCreateResult` 类型

**验收结果**：
- ✅ Agent工厂返回清理函数
- ✅ 类型检查通过

---

### 功能点3：修改API在onFinish中清理资源 ✅
**状态**：已完成
**完成日期**：2026-02-22

**涉及文件**：
- `app/api/chat/route.ts`（修改）

**实现内容**：
1. 解构获取 `cleanup` 函数
2. 在 `onFinish` 回调末尾调用 `await cleanup()`
3. 确保MCP客户端在响应完成后正确关闭

**验收结果**：
- ✅ MCP工具调用正常工作
- ✅ 资源在正确时机释放
- ✅ 类型检查通过

---

## 开发问题与解决

### 问题1：MCP工具调用报错
**现象**：调用MCP工具时返回错误 "Attempted to send a request from a closed client"

**原因**：
- `createLangChainMCPTools()` 在获取工具后立即调用 `mcpClient.close()`
- MCP工具需要保持客户端连接才能执行
- 关闭客户端后，后续工具调用无法发送请求

**解决**：
1. 不在工具创建时关闭MCP客户端
2. 返回 `cleanup` 函数，由调用者决定何时关闭
3. 在API的 `onFinish` 回调中调用清理函数

### 问题2：bash-tool沙盒不持久化
**现象**：Agent写入文件后，在同一循环内可以读取，但下次请求时沙盒为空

**原因**：
- 每次API请求都调用 `createBashTool({ files: {} })` 创建新沙盒
- 新沙盒默认为空，不保留之前的状态

**解决方案**（暂不实现）：
- 使用 `@vercel/sandbox` 创建持久化沙盒
- 在数据库或前端存储 `sandboxId`
- 每次请求时重用已有沙盒

**当前决策**：暂时接受每次对话沙盒重置的行为

---

## 总结

### 第3期补充2开发完成情况

**完成日期**：2026-02-22

**功能点完成情况**：
- ✅ 功能点1：修改tools.ts返回清理函数
- ✅ 功能点2：修改Agent工厂返回清理函数
- ✅ 功能点3：修改API在onFinish中清理资源

**总体进度**：3/3 (100%)

### 主要技术实现

1. **资源生命周期管理**：工具创建与清理分离，由调用者控制生命周期
2. **清理函数模式**：返回 `{ tools, cleanup }` 或 `{ agent, cleanup }` 统一管理资源
3. **响应完成清理**：在 `onFinish` 回调中安全释放资源

### 功能验证

| 工具 | 状态 | 说明 |
|------|------|------|
| bash | ✅ | 命令执行、文件读写正常 |
| tavily | ✅ | 网络搜索正常 |
| mcp | ✅ | LangChain文档查询正常（修复后） |

| 模块 | 进度 |
|------|------|
| tools.ts修改 | 1/1 ✅ |
| index.ts修改 | 1/1 ✅ |
| route.ts修改 | 1/1 ✅ |
| **第3期补充2总计** | **3/3 (100%)** |
