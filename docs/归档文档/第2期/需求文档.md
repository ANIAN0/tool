# 第2期需求文档：多Agent切换功能

## 一、项目概述

### 1.1 目标
在第1期多轮对话Agent的基础上，实现多Agent切换功能。支持"正式Agent"和"开发Agent"的切换，每个Agent使用独立的系统提示词配置。

### 1.2 技术方案
基于AI SDK的 **Routing模式** 实现，核心思路：
- 前端：添加Agent选择器组件，用户可切换当前使用的Agent
- 后端：根据选择的Agent ID，动态加载对应的系统提示词
- 配置：使用配置文件管理多个Agent的系统提示词

### 1.3 核心决策
| 决策项 | 选择 |
|--------|------|
| Agent数量 | 初始2个（正式、开发），可扩展 |
| 配置方式 | 代码配置 `lib/agents/config.ts` |
| 切换位置 | 对话页面顶部（与模型选择器并列） |
| 切换范围 | **对话独立Agent**（每个对话关联Agent，切换对话时自动切换） |
| 存储策略 | Agent ID存储在对话记录中（数据库） |

---

## 二、功能点拆分

### 模块一：配置与类型

#### 功能点1：Agent配置与类型定义
**描述**：创建Agent配置文件，定义Agent类型和配置结构。

**涉及文件**：
- `lib/agents/config.ts`（新建）：Agent配置和类型定义

**配置结构设计**：
```typescript
// Agent配置接口
interface AgentConfig {
  id: string;           // Agent唯一标识
  name: string;         // 显示名称
  description: string;  // 描述（可选）
  systemPrompt: string; // 系统提示词
}

// 预定义的Agent列表
export const AGENTS: AgentConfig[] = [
  {
    id: 'production',
    name: '正式Agent',
    description: '正式环境使用的Agent',
    systemPrompt: '你是一个有帮助的AI助手...',
  },
  {
    id: 'development',
    name: '开发Agent',
    description: '开发测试使用的Agent',
    systemPrompt: '你是一个开发测试用的AI助手...',
  },
];
```

**验收标准**：
- 类型定义完整
- 默认配置包含两个Agent
- 提供获取Agent配置的工具函数

---

### 模块二：数据存储

#### 功能点2：数据库Schema修改
**描述**：在conversations表中添加agent_id字段，记录对话使用的Agent。

**涉及文件**：
- `lib/db/schema.ts`（修改）：添加agent_id字段

**修改内容**：
```sql
-- conversations表新增字段
ALTER TABLE conversations ADD COLUMN agent_id TEXT DEFAULT 'production';
```

**验收标准**：
- Schema定义更新
- 现有对话默认使用正式Agent

---

#### 功能点3：对话数据访问层修改
**描述**：修改对话CRUD操作，支持agent_id的存储和查询。

**涉及文件**：
- `lib/db/conversations.ts`（修改）：添加agent_id参数

**修改内容**：
- `createConversation` 添加 agent_id 参数
- `getConversation` 返回 agent_id 字段

**验收标准**：
- 创建对话时记录agent_id
- 查询对话时返回agent_id

---

### 模块三：后端API

#### 功能点4：修改聊天API支持Agent切换
**描述**：修改 `/api/chat` 接口，根据agentId动态加载系统提示词，并在创建对话时记录agent_id。

**涉及文件**：
- `app/api/chat/route.ts`（修改）：添加agentId参数处理

**修改内容**：
```typescript
// 请求格式新增 agentId 参数
POST /api/chat
Body: { 
  messages: UIMessage[], 
  conversationId?: string, 
  model?: string,
  agentId?: string  // 新增
}

// 根据agentId获取系统提示词
const agentConfig = getAgentConfig(agentId || 'production');
const systemPrompt = agentConfig.systemPrompt;

// 创建对话时记录agent_id
await createConversation({
  id: currentConversationId,
  userId,
  title,
  model: modelName,
  agentId: agentId || 'production',  // 新增
});
```

**验收标准**：
- API支持agentId参数
- 默认使用正式Agent
- 正确加载对应的系统提示词
- 创建对话时记录agent_id

---

### 模块四：前端组件

#### 功能点5：Agent选择器组件
**描述**：创建Agent选择器组件，显示可用的Agent列表并支持切换。

**涉及文件**：
- `components/chat/agent-selector.tsx`（新建）：Agent选择器组件

**功能要求**：
- 下拉选择Agent
- 显示当前选中的Agent名称
- 样式与模型选择器一致

**验收标准**：
- 选择器正常工作
- 选中状态正确显示

---

#### 功能点6：对话页面集成Agent选择器 ✅
**描述**：在对话页面集成Agent选择器，实现对话独立Agent的逻辑。

**涉及文件**：
- `app/chat/page.tsx`（修改）：集成Agent选择器

**修改内容**：
- 添加Agent选择状态
- 在header中显示Agent选择器（始终可见，历史对话时禁用）
- 将agentId传递给API
- **切换对话时**：从对话记录中读取agent_id，自动切换Agent选择器
- **新建对话时**：使用当前选择的Agent
- **发送消息时**：传递当前Agent ID给API
- 使用useRef确保agentId始终是最新值

**验收标准**：
- ✅ Agent选择器正确显示
- ✅ 切换对话时自动切换到对话关联的Agent
- ✅ 新建对话使用当前选择的Agent
- ✅ 发送消息时正确传递agentId
- ✅ 历史对话时Agent选择器禁用但显示当前Agent

---

## 三、功能点总览

| 序号 | 功能点 | 模块 | 涉及文件数 | 状态 |
|------|--------|------|------------|------|
| 1 | Agent配置与类型定义 | 配置与类型 | 1 | ✅ |
| 2 | 数据库Schema修改 | 数据存储 | 1 | ✅ |
| 3 | 对话数据访问层修改 | 数据存储 | 1 | ✅ |
| 4 | 修改聊天API支持Agent切换 | 后端API | 1 | ✅ |
| 5 | Agent选择器组件 | 前端组件 | 1 | ✅ |
| 6 | 对话页面集成Agent选择器 | 页面集成 | 1 | ✅ |

**共计：6个功能点，全部完成**

---

## 四、依赖关系

```
功能点1（配置）→ 功能点2（Schema）→ 功能点3（数据访问层）→ 功能点4（API）→ 功能点5（组件）→ 功能点6（集成）
```

---

## 五、扩展性考虑

### 5.1 未来可扩展方向
1. **更多Agent**：只需在配置文件中添加新的Agent配置
2. **Agent管理界面**：可视化管理Agent（增删改）
3. **Agent工具配置**：不同Agent可配置不同的工具集
4. **Agent权限控制**：限制某些用户只能使用特定Agent

### 5.2 配置外置化
当前方案使用代码配置，未来可考虑：
- 配置存储到数据库
- 支持环境变量配置
- 支持动态加载配置

---

## 六、参考资源

- [AI SDK Workflow Patterns - Routing](https://ai-sdk.dev/docs/agents/workflows#routing)
- [AI SDK Type-Safe Agents](https://ai-sdk.dev/docs/agents/building-agents)

---

# 第3期需求文档：Agent工具配置功能

## 一、项目概述

### 1.1 目标
在第2期多Agent切换功能的基础上，实现不同Agent的工具配置隔离。正式Agent和开发Agent可以使用不同的工具集，满足不同场景的需求。

### 1.2 技术方案
基于AI SDK的 **工具注册表** 模式实现：
- 工具管理：创建 `lib/agents/tools.ts` 统一管理工具创建
- 配置扩展：在 `AgentConfig` 接口中添加 `tools` 字段
- 动态加载：根据Agent配置动态创建对应的工具集合
- API集成：在聊天API中根据agentId加载并传递工具

### 1.3 核心决策
| 决策项 | 选择 |
|--------|------|
| 工具管理方式 | 代码配置 `lib/agents/tools.ts` |
| 工具类型 | bash-tool、tavily、mcp（docs-langchain） |
| 正式Agent工具 | bash-tool |
| 开发Agent工具 | bash-tool + tavily + mcp |
| MCP实现 | 使用 `@ai-sdk/mcp` 连接 docs.langchain.com/mcp |

---

## 二、功能点拆分

### 模块一：依赖安装

#### 功能点1：安装依赖并配置环境变量
**描述**：安装必要的依赖包并配置环境变量。

**涉及文件**：
- `package.json`（修改）：添加 @modelcontextprotocol/sdk 依赖
- `.env`（修改）：添加 TAVILY_API_KEY 配置

**验收标准**：
- 所有依赖安装成功
- TAVILY_API_KEY 配置项已添加

---

### 模块二：配置修改

#### 功能点2：修改Agent配置接口
**描述**：在Agent配置接口中添加工具字段，支持为每个Agent配置不同的工具。

**涉及文件**：
- `lib/agents/config.ts`（修改）

**修改内容**：
```typescript
// AgentConfig接口添加tools字段
export interface AgentConfig {
  id: string;
  name: string;
  description: string;
  systemPrompt: string;
  tools?: Array<'bash' | 'tavily' | 'mcp'>; // 新增
}

// 正式Agent配置
{
  id: "production",
  name: "正式Agent",
  description: "正式环境使用的Agent，提供稳定可靠的AI服务",
  systemPrompt: "...",
  tools: ['bash'], // 仅启用bash工具
}

// 开发Agent配置
{
  id: "development",
  name: "开发Agent",
  description: "开发测试使用的Agent，用于新功能测试和调试",
  systemPrompt: "...",
  tools: ['bash', 'tavily', 'mcp'], // 启用所有工具
}
```

**验收标准**：
- 接口定义更新
- 正式Agent仅配置bash工具
- 开发Agent配置全部工具

---

### 模块三：工具管理

#### 功能点3：创建工具配置模块
**描述**：创建统一的工具配置模块，负责创建和管理各种工具。

**涉及文件**：
- `lib/agents/tools.ts`（新建）

**功能要求**：
- 定义工具类型：`'bash' | 'tavily' | 'mcp'`
- 实现 `createBashTools()` 创建bash工具
- 实现 `createTavilyTools()` 创建tavily搜索工具
- 实现 `createLangChainMCPTools()` 创建MCP工具（占位）
- 实现 `createToolsByTypes()` 根据类型列表创建工具集合
- 导出配置和辅助函数

**验收标准**：
- 工具类型定义清晰
- 支持创建所有类型的工具
- 类型检查通过（使用ToolSet）

---

### 模块四：API集成

#### 功能点4：修改聊天API支持工具
**描述**：修改聊天API，根据Agent配置动态加载工具并传递给模型。

**涉及文件**：
- `app/api/chat/route.ts`（修改）

**修改内容**：
```typescript
// 导入工具创建函数
import { createToolsByTypes } from "@/lib/agents/tools";

// 根据Agent配置创建工具
const agentConfig = getAgentConfig(currentAgentId || DEFAULT_AGENT_ID);
const tools = await createToolsByTypes(agentConfig.tools || []);

// 调用streamText时传递工具
const result = streamText({
  model: wrappedModel,
  system: agentConfig.systemPrompt,
  messages: modelMessages,
  tools: Object.keys(tools).length > 0 ? tools : undefined,
  // ...
});
```

**验收标准**：
- 根据agentId加载对应工具
- 正式Agent使用bash工具
- 开发Agent使用所有可用工具
- 类型检查通过

---

## 三、功能点总览

| 序号 | 功能点 | 模块 | 涉及文件数 | 状态 |
|------|--------|------|------------|------|
| 1 | 安装依赖并配置环境变量 | 依赖安装 | 2 | ✅ |
| 2 | 修改Agent配置接口 | 配置修改 | 1 | ✅ |
| 3 | 创建工具配置模块 | 工具管理 | 1 | ✅ |
| 4 | 修改聊天API支持工具 | API集成 | 1 | ✅ |

**共计：4个功能点，全部完成**

---

## 四、依赖关系

```
功能点1（依赖安装）→ 功能点2（配置修改）→ 功能点3（工具模块）→ 功能点4（API集成）
```

---

## 五、工具说明

### 5.1 Bash Tool
**包名**：`bash-tool`
**功能**：提供bash命令执行、文件读写能力
**用途**：执行命令、读取和写入文件

### 5.2 Tavily
**包名**：`@tavily/ai-sdk`
**功能**：提供实时网络搜索能力
**用途**：搜索最新信息、获取实时数据
**配置**：需要TAVILY_API_KEY环境变量

### 5.3 MCP (docs-langchain)
**包名**：`@ai-sdk/mcp`
**功能**：连接LangChain文档MCP服务器
**用途**：查询LangChain、LangGraph、LangSmith文档
**实现**：使用 `createMCPClient` 连接 `https://docs.langchain.com/mcp`
**注意事项**：MCP客户端需要保持连接，在响应完成后关闭

---

## 六、注意事项

1. **MCP工具**：使用 `@ai-sdk/mcp` 的 `createMCPClient` 连接，需要在响应完成后关闭客户端
2. **API密钥**：Tavily需要有效的API密钥才能使用搜索功能
3. **安全性**：bash工具在服务端执行，需要确保环境安全
4. **类型安全**：使用AI SDK的ToolSet类型确保类型正确
5. **资源管理**：工具创建返回清理函数，在 `onFinish` 中调用释放资源

---

## 七、参考资源

- [AI SDK Tools Registry - bash-tool](https://ai-sdk.dev/tools-registry/bash-tool)
- [AI SDK Tools Registry - Tavily](https://ai-sdk.dev/tools-registry/tavily)
- [AI SDK Tools Registry - MCP](https://ai-sdk.dev/tools-registry/mcp)
- [Tavily Documentation](https://docs.tavily.com/documentation/integrations/vercel)
- [LangChain Docs MCP](https://docs.langchain.com/use-these-docs)

---

# 第3期需求文档（修订）：使用ToolLoopAgent重构

## 一、项目概述

### 1.1 背景
第3期初步实现后发现工具调用无法正常工作。经过分析，原因是：
1. `streamText` 需要手动处理多步骤调用（`stopWhen`）
2. 前端需要处理 `parts` 显示工具调用和结果
3. 消息存储需要保存完整的对话历史

### 1.2 目标
使用 AI SDK 的 `ToolLoopAgent` 重构聊天API，实现：
- 自动处理工具调用循环（Reasoning-and-Acting Loop）
- 类型安全的消息类型推断
- 更好的多步骤Agent体验

### 1.3 技术方案对比

| 对比项 | `streamText` | `ToolLoopAgent` |
|--------|-------------|-----------------|
| 适用场景 | 简单聊天 | 复杂多步Agent |
| 工具调用 | 需手动实现 `stopWhen` | **自动处理循环** |
| 消息管理 | 需自己管理 | **自动管理** |
| 类型安全 | 基础类型 | **`InferAgentUIMessage`** |
| 扩展性 | 一般 | **支持输出解析、回调等** |

### 1.4 核心决策

| 决策项 | 选择 |
|--------|------|
| Agent实现方式 | **ToolLoopAgent**（自动多步骤循环） |
| 停止条件 | `stepCountIs(10)`（最多10步） |
| 消息类型 | 使用 `InferAgentUIMessage` 类型推断 |
| 前端集成 | 使用 `useChat` hook，渲染 `parts` |

---

## 二、功能点拆分

### 模块一：Agent工厂

#### 功能点1：创建Agent工厂函数
**描述**：创建Agent工厂函数，根据agentId动态创建ToolLoopAgent实例。

**涉及文件**：
- `lib/agents/index.ts`（新建）：Agent工厂函数

**实现内容**：
```typescript
import { ToolLoopAgent, stepCountIs } from 'ai';
import { getAgentConfig } from './config';
import { createToolsByTypes } from './tools';

export async function createAgent(
  agentId: string, 
  model: LanguageModel
): Promise<ToolLoopAgent> {
  const config = getAgentConfig(agentId);
  const tools = await createToolsByTypes(config.tools || []);
  
  return new ToolLoopAgent({
    model,
    instructions: config.systemPrompt,
    tools,
    stopWhen: stepCountIs(10),
  });
}
```

**验收标准**：
- 根据agentId正确创建Agent实例
- 正确加载系统提示词和工具
- 类型检查通过

---

### 模块二：API重构

#### 功能点2：修改聊天API使用ToolLoopAgent
**描述**：重构 `/api/chat` 路由，使用ToolLoopAgent替代streamText。

**涉及文件**：
- `app/api/chat/route.ts`（重构）

**修改内容**：
```typescript
// 创建Agent实例
const agent = await createAgent(agentId, wrappedModel);

// 使用Agent的stream方法
const result = agent.stream({
  messages: modelMessages,
});

// 返回流式响应
return result.toUIMessageStreamResponse();
```

**验收标准**：
- API正确使用ToolLoopAgent
- 工具调用自动循环执行
- 返回正确的流式响应

---

### 模块三：前端集成

#### 功能点3：修改前端消息显示
**描述**：修改前端消息渲染，支持显示工具调用和步骤。

**涉及文件**：
- `app/chat/page.tsx`（修改）：消息渲染逻辑
- `components/ai-elements/message.tsx`（修改）：支持工具调用显示

**修改内容**：
```typescript
// 渲染消息parts
message.parts.map((part) => {
  switch (part.type) {
    case 'text':
      return <TextContent text={part.text} />;
    case 'tool-bash':
    case 'tool-tavilySearch':
    case 'dynamic-tool':
      // 显示工具调用和结果
      return <ToolCallDisplay part={part} />;
    case 'step-start':
      // 显示步骤分隔线（可选）
      return <StepDivider />;
  }
});
```

**验收标准**：
- 正确显示文本消息
- 正确显示工具调用（input-streaming、input-available、output-available、output-error状态）
- 正确显示工具结果

---

### 模块四：消息存储

#### 功能点4：修改消息存储逻辑
**描述**：修改消息存储逻辑，正确保存包含工具调用的消息。

**涉及文件**：
- `lib/db/messages.ts`（修改）：消息存储格式
- `app/api/chat/route.ts`（修改）：onFinish回调

**修改内容**：
- 使用 `response.messages` 保存完整对话历史
- 或者只保存最终的text内容（简化方案）

**验收标准**：
- 消息正确存储到数据库
- 历史消息正确加载
- 工具调用记录可选保存

---

## 三、功能点总览

| 序号 | 功能点 | 模块 | 涉及文件数 | 状态 |
|------|--------|------|------------|------|
| 1 | 创建Agent工厂函数 | Agent工厂 | 1 | ✅ |
| 2 | 修改聊天API使用ToolLoopAgent | API重构 | 1 | ✅ |
| 3 | 修改前端消息显示 | 前端集成 | 2 | ✅ |
| 4 | 修改消息存储逻辑 | 消息存储 | 2 | ✅ |

**共计：4个功能点，全部完成**

---

## 四、依赖关系

```
功能点1（Agent工厂）→ 功能点2（API重构）→ 功能点3（前端显示）→ 功能点4（消息存储）
```

---

## 五、消息类型说明

### 5.1 UIMessage Parts类型

使用ToolLoopAgent后，消息的 `parts` 数组包含以下类型：

| Part类型 | 说明 |
|----------|------|
| `text` | 文本内容 |
| `tool-{toolName}` | 工具调用（如 `tool-bash`、`tool-tavilySearch`） |
| `dynamic-tool` | 动态工具（如MCP工具） |
| `step-start` | 步骤开始标记 |

### 5.2 工具调用状态

工具调用part的 `state` 属性：

| 状态 | 说明 |
|------|------|
| `input-streaming` | 输入参数正在流式生成 |
| `input-available` | 输入参数已完整 |
| `output-available` | 工具执行成功，结果可用 |
| `output-error` | 工具执行失败 |

---

## 六、注意事项

1. **模型支持**：使用的模型必须支持工具调用（function calling）
2. **步骤限制**：设置合理的 `stopWhen` 条件，避免无限循环
3. **错误处理**：正确处理工具执行失败的情况
4. **性能考虑**：工具调用可能增加响应时间

---

## 七、参考资源

- [AI SDK ToolLoopAgent](https://ai-sdk.dev/docs/reference/ai-sdk-core/tool-loop-agent)
- [AI SDK Chatbot Tool Usage](https://ai-sdk.dev/docs/ai-sdk-ui/chatbot-tool-usage)
- [AI SDK InferAgentUIMessage](https://ai-sdk.dev/docs/reference/ai-sdk-core/tool-loop-agent#inferagentuimessage)
