# 第2期需求讨论记录

## 讨论1：多Agent切换功能需求确认

**日期**：2026-02-21

### 用户需求
当前项目已完成第1期内容开发，实现了多轮对话agent。接下来第2期，希望实现多agent切换功能：
1. 保留现有agent作为"agent正式"
2. 复制一份作为"agent开发"
3. 在对话页面可切换
4. 配置文件分开配置系统提示词

### 技术方案分析

#### 方案选择：Routing模式
参考AI SDK的[Workflow Patterns - Routing](https://ai-sdk.dev/docs/agents/workflows#routing)：
- Routing模式允许根据上下文选择不同的处理路径
- 适用于需要根据用户选择使用不同配置的场景
- 实现简单，扩展性好

#### 核心设计
1. **配置管理**：创建 `lib/agents/config.ts` 存放所有Agent配置
2. **API改造**：修改 `/api/chat` 接受 `agentId` 参数，动态加载系统提示词
3. **前端组件**：创建Agent选择器组件，与模型选择器并列显示
4. **状态持久化**：Agent选择保存在 localStorage

### 功能点拆分（共4个）

| 序号 | 功能点 | 说明 |
|------|--------|------|
| 1 | Agent配置与类型定义 | 创建配置文件，定义正式/开发两个Agent |
| 2 | 修改聊天API | 支持根据agentId加载不同系统提示词 |
| 3 | Agent选择器组件 | 下拉选择Agent，样式与模型选择器一致 |
| 4 | 页面集成 | 在对话页面header添加Agent选择器 |

### 待确认问题

1. **Agent切换范围**：全局切换 vs 每个对话独立Agent？
   - 当前方案：全局切换（简单实现）
   - 备选方案：每个对话关联Agent（切换对话时自动切换Agent）

2. **配置管理方式**：代码配置 vs 数据库/环境变量？
   - 当前方案：代码配置（快速实现）
   - 备选方案：数据库存储（支持动态管理）

3. **是否需要Agent描述/图标**？
   - 当前方案：仅显示名称
   - 备选方案：支持描述和自定义图标

---

### 决策记录

**日期**：2026-02-21

| 问题 | 决策 | 说明 |
|------|------|------|
| Agent切换范围 | **对话独立Agent** | 每个对话记录使用的Agent，切换对话时自动切换Agent |
| 配置管理方式 | **代码配置** | 在 `lib/agents/config.ts` 中配置 |

**影响**：
- 需要修改数据库schema，添加 `agent_id` 字段
- 需要修改对话CRUD操作
- 前端需要实现切换对话时自动切换Agent的逻辑
- 功能点从4个增加到6个

---

## 讨论2：开发问题修复

**日期**：2026-02-21

### 发现的问题

1. **Agent切换没有生效**：选择开发Agent后，发送消息仍然使用正式Agent
2. **历史对话隐藏Agent选择器**：用户无法知道当前对话使用的是哪个Agent
3. **产品设计问题**：一个对话应该始终使用创建时的Agent，不应该允许切换

### 问题分析

1. **状态同步问题**：`selectedAgentId` 状态没有正确传递到API请求中
2. **UI设计问题**：错误地隐藏了历史对话的Agent选择器
3. **产品设计误解**：应该显示当前对话的Agent，但不允许修改

### 解决方案

1. **使用useRef确保状态同步**：
   ```typescript
   const agentIdRef = useRef<string>(selectedAgentId);
   useEffect(() => {
     agentIdRef.current = selectedAgentId;
   }, [selectedAgentId]);
   ```

2. **始终显示Agent选择器**：
   - 新建对话时：Agent选择器可用
   - 历史对话时：Agent选择器禁用但显示当前Agent

3. **API正确处理Agent**：
   - 有conversationId时：使用对话关联的agent_id
   - 无conversationId时：使用请求体中的agentId

### 验证结果

✅ 新建对话时Agent切换正常
✅ 历史对话显示Agent选择器（但禁用）
✅ 发送消息时正确传递Agent ID
✅ API正确加载对应的系统提示词

---

## 讨论3：需求文档更新

**日期**：2026-02-21

### 更新内容

1. 更新功能点6的验收标准：
   - 添加"历史对话时Agent选择器禁用但显示当前Agent"

2. 更新功能点总览，添加状态列：
   - 所有6个功能点标记为已完成 ✅

3. 完善功能点6的实现说明：
    - 添加useRef确保状态同步的说明
    - 明确历史对话时Agent选择器的行为

---

## 讨论4：第3期工具配置功能

**日期**：2026-02-21

### 用户需求
多agent的目的是为了，不同的agent可以设置不同的提示词，配置不同的工具。需要为不同Agent配置工具：
- 正式Agent：bash-tool
- 开发Agent：bash-tool + tavily + docs-langchain MCP

### 技术方案

1. **修改Agent配置接口**：添加tools字段
2. **创建工具配置模块**：`lib/agents/tools.ts`，统一管理工具
3. **修改聊天API**：根据agentId加载对应的工具配置
4. **环境变量配置**：添加TAVILY_API_KEY

### 功能点拆分（共4个）

| 序号 | 功能点 | 说明 |
|------|--------|------|
| 1 | 安装依赖并配置环境变量 | 安装bash-tool、@tavily/ai-sdk、@modelcontextprotocol/sdk，添加API密钥 |
| 2 | 修改Agent配置接口 | 添加tools字段支持工具配置 |
| 3 | 创建工具配置模块 | 统一管理bash-tool、tavily、MCP工具 |
| 4 | 修改聊天API支持工具 | 根据agentId动态加载工具并传递给streamText |

### 待确认问题
无，直接开始实现

---

## 讨论5：MCP工具实现修复

**日期**：2026-02-21

### 发现的问题
用户反馈MCP工具实现不正确。LangChain提供了公共的MCP服务器，应该作为客户端连接使用，不需要鉴权。

### 问题分析
之前的实现使用占位返回空对象，没有实际连接到MCP服务器。

### 解决方案
根据AI SDK MCP文档正确实现：
1. 使用 `@ai-sdk/mcp` 包中的 `createMCPClient`
2. 使用HTTP传输连接到 `https://docs.langchain.com/mcp`
3. 调用 `mcpClient.tools()` 获取工具
4. 使用后关闭MCP客户端连接

### 验证结果
✅ 正确连接到LangChain文档MCP服务器
✅ 获取MCP工具并转换为AI SDK工具格式
✅ 类型检查通过

---

## 讨论6：工具调用无法正常工作

**日期**：2026-02-21

### 发现的问题
1. 调用工具后，对话就结束了，没有获取工具调用结果
2. 没有AI的回复文本

### 问题分析
根据AI SDK文档分析：
1. **前端问题**：前端消息组件没有处理 `parts` 属性，只显示文本内容
2. **API问题**：`onFinish` 回调只保存 `text` 参数，没有保存完整的消息历史
3. **工具调用流程**：AI SDK的 `useChat` hook + `streamText` 支持完整的工具调用流程
   - 工具调用通过 `tool-call` 类型的part传递到前端
   - 工具结果通过 `tool-result` 类型的part传递到前端
   - 前端需要渲染 `parts` 来显示工具调用和结果

### 解决方案
1. 修改API：在 `onFinish` 中保存完整的对话历史，而不是只保存文本
2. 修改前端消息组件：支持显示 `parts`，包括 tool-call 和 tool-result
3. 确保使用 `useChat` hook 的正确用法

### 待实现
需要重新设计消息存储和显示逻辑以支持工具调用

---

## 讨论7：使用ToolLoopAgent重构

**日期**：2026-02-21

### 技术方案对比

| 对比项 | 继续使用 `streamText` | 替换为 `ToolLoopAgent` |
|--------|----------------------|----------------------|
| **适用场景** | 简单聊天 | 复杂的多步Agent，需要自动循环 |
| **工具调用** | 需要手动实现多步骤（`stopWhen`） | **自动处理**多步骤循环 |
| **消息管理** | 需要自己管理消息历史 | **自动管理**，返回 `steps` 和 `text` |
| **前端集成** | 需要处理 `parts` 显示工具调用 | 需要处理 `steps` 显示工具调用 |
| **代码复杂度** | 较低，但需要手动处理多步骤 | 较高，但自动化程度高 |

### 决策：使用ToolLoopAgent

**原因**：
1. **自动化**：自动处理工具调用循环，无需手动实现 `stopWhen`
2. **类型安全**：提供 `InferAgentUIMessage` 类型推断
3. **更好体验**：自动推理和行动循环，符合真正的 "Agent" 概念
4. **未来扩展**：更容易添加输出解析、步骤回调等高级功能

### 技术方案

#### 1. 创建Agent实例
在 `lib/agents/` 下创建Agent实例，根据agentId获取对应的Agent配置：

```typescript
// lib/agents/index.ts
import { ToolLoopAgent } from 'ai';
import { getAgentConfig } from './config';
import { createToolsByTypes } from './tools';

export async function createAgent(agentId: string, model: LanguageModel) {
  const config = getAgentConfig(agentId);
  const tools = await createToolsByTypes(config.tools || []);
  
  return new ToolLoopAgent({
    model,
    instructions: config.systemPrompt,
    tools,
    stopWhen: stepCountIs(10),
  });
}
```

#### 2. 修改API路由
使用Agent的 `stream()` 方法替代 `streamText`：

```typescript
// app/api/chat/route.ts
const agent = await createAgent(agentId, wrappedModel);
const result = agent.stream({
  messages: modelMessages,
});
return result.toUIMessageStreamResponse();
```

#### 3. 前端集成
使用 `useChat` hook，消息会自动包含工具调用的steps：

```typescript
// 消息parts会包含：
// - 'text': 文本内容
// - 'tool-{toolName}': 工具调用和结果
// - 'step-start': 步骤开始标记
```

### 功能点拆分（共4个）

| 序号 | 功能点 | 说明 |
|------|--------|------|
| 1 | 创建Agent工厂函数 | 根据agentId创建ToolLoopAgent实例 |
| 2 | 修改API使用Agent | 替换streamText为ToolLoopAgent.stream() |
| 3 | 修改前端消息显示 | 支持显示工具调用和步骤 |
| 4 | 修改消息存储逻辑 | 正确保存包含工具调用的消息 |

### 影响范围
- `lib/agents/`：新增Agent工厂函数
- `app/api/chat/route.ts`：重构使用ToolLoopAgent
- `app/chat/page.tsx`：修改消息渲染逻辑
- `lib/db/messages.ts`：可能需要修改消息存储格式

---

### 验证结果

**日期**：2026-02-21

✅ Agent工厂函数创建完成
✅ API重构为使用ToolLoopAgent
✅ 消息存储逻辑正确
✅ 类型检查通过

---

## 讨论8：前端工具显示组件修正

**日期**：2026-02-21

### 发现的问题
在讨论7中，我错误地创建了自定义的 `tool-call-display.tsx` 组件，而没有使用项目中已有的官方 AI Elements Tool 组件。

### 问题分析
1. 项目已有 `components/ai-elements/tool.tsx`，包含官方的 Tool 组件
2. 我没有先查看现有组件就创建了重复功能
3. 没有按照最佳实践使用官方组件

### 解决方案
1. 删除自定义的 `components/chat/tool-call-display.tsx`
2. 使用官方 Tool 组件：`Tool`, `ToolHeader`, `ToolContent`, `ToolInput`, `ToolOutput`
3. 正确处理静态工具和动态工具的类型差异

### 修改内容
- 删除 `components/chat/tool-call-display.tsx`
- 修改 `app/chat/page.tsx`，导入并使用官方 Tool 组件
- 添加 `isToolPart()` 和 `isStepStartPart()` 辅助函数

### 验证结果
✅ 删除自定义组件
✅ 使用官方 Tool 组件
✅ 类型检查通过

---

## 讨论9：消息存储方案决策

**日期**：2026-02-21

### 需求
保存完整消息，包括工具调用过程。

### 技术方案对比

| 方案 | 描述 | 优点 | 缺点 |
|------|------|------|------|
| **A. 扩展content字段** | 将content改为存储完整UIMessage的JSON字符串 | 无需修改schema | content字段语义改变，需要迁移现有数据 |
| **B. 新增parts字段** | 添加 `parts TEXT` 字段存储JSON数组 | 保留content字段语义 | 需要修改schema，增加迁移SQL |

### 决策：方案A - 扩展content字段

**原因**：
1. 无需修改数据库schema
2. 改动范围小
3. 现有数据可以平滑迁移（纯文本消息兼容）

### UIMessage结构（需要保存的内容）

```typescript
interface UIMessage {
  id: string;
  role: "user" | "assistant";
  parts: Array<
    | { type: "text"; text: string }
    | { type: "tool-{toolName}"; toolCallId: string; input: unknown; output: unknown; state: string; ... }
    | { type: "dynamic-tool"; toolName: string; ... }
    | { type: "step-start" }
  >;
}
```

### 涉及修改文件

| 文件 | 修改内容 |
|------|----------|
| `lib/db/messages.ts` | 修改createMessage和getMessages函数，支持存储/读取JSON |
| `app/api/chat/route.ts` | 修改onFinish回调，保存完整消息parts |
| `app/chat/page.tsx` | 修改dbMessageToUIMessage函数，解析JSON |

### 功能点拆分

| 1 | 修改消息存储函数 | 支持存储完整UIMessage的JSON |
| 2 | 修改消息读取函数 | 解析JSON并返回UIMessage |
| 3 | 修改API的onFinish | 保存完整消息parts |

### 实现完成

**日期**：2026-02-21

#### 功能点1：修改schema.ts
- 更新messages表注释，说明content字段可存储JSON
- 添加MessagePart和FullMessage类型定义

#### 功能点2：修改前端消息解析
- 修改`dbMessageToUIMessage()`函数
- 支持解析JSON格式的content
- 兼容纯文本格式（历史数据）

#### 功能点3：修改API的onFinish
- 添加`buildPartsFromSteps()`辅助函数
- 从Agent的steps构建UIMessage parts
- 用户消息和助手消息都保存完整JSON结构

### 验证结果
✅ schema类型定义更新
✅ 前端消息解析支持JSON
✅ API保存完整消息结构
✅ 类型检查通过

---

## 讨论10：MCP工具调用报错修复

**日期**：2026-02-22

### 发现的问题
调用MCP工具时返回错误：
```json
{
  "type": "error-text",
  "value": "Attempted to send a request from a closed client"
}
```

### 问题分析
1. 在 `lib/agents/tools.ts` 的 `createLangChainMCPTools()` 函数中，获取工具后立即关闭了MCP客户端
2. MCP工具需要保持客户端连接才能执行远程调用
3. 关闭客户端后，工具执行时无法发送请求到MCP服务器

**错误代码**：
```typescript
// 错误：获取工具后立即关闭客户端
const tools = await mcpClient.tools();
await mcpClient.close();  // ← 问题所在
return tools;
```

### 解决方案
参考AI SDK MCP文档的正确用法：

> When streaming responses, you can close the client when the LLM response has finished. For example, when using `streamText`, you should use the `onFinish` callback.

实现资源生命周期管理：

1. **修改 `tools.ts`**：
   - `createLangChainMCPTools()` 返回 `{ tools, mcpClient }`，不关闭客户端
   - `createToolsByTypes()` 返回 `{ tools, cleanup }`，提供清理函数

2. **修改 `index.ts`**：
   - `createAgent()` 返回 `{ agent, cleanup }`，透传清理函数

3. **修改 `route.ts`**：
   - 在 `onFinish` 回调中调用 `await cleanup()`
   - 确保响应完成后才关闭MCP客户端

### 修改文件

| 文件 | 修改内容 |
|------|----------|
| `lib/agents/tools.ts` | 返回清理函数，不再提前关闭客户端 |
| `lib/agents/index.ts` | 透传清理函数 |
| `app/api/chat/route.ts` | onFinish中调用cleanup() |

### 验证结果
✅ MCP工具调用正常工作
✅ LangChain文档查询正常
✅ 资源在正确时机释放
✅ 类型检查通过

---

## 讨论11：bash-tool沙盒持久化问题

**日期**：2026-02-22

### 发现的问题
Agent使用bash-tool写入文件后：
- 在Agent循环内可以读取写入的文件
- 一旦Agent输出结果，再次发送消息时沙盒为空

### 问题分析
1. 每次API请求都调用 `createBashTool({ files: {} })` 创建新的沙盒
2. 新沙盒默认为空，不保留之前的状态
3. bash-tool的沙盒生命周期仅限于单次请求

### 持久化方案
根据bash-tool文档，可以使用 `@vercel/sandbox` 实现持久化：

```typescript
import { Sandbox } from "@vercel/sandbox";

// 首次：创建沙盒，存储ID
const sandbox = await Sandbox.create();
const sandboxId = sandbox.sandboxId;

// 后续：重用已有沙盒
const existingSandbox = await Sandbox.get({ sandboxId });
const { tools } = await createBashTool({ sandbox: existingSandbox });
```

**需要**：
1. 安装 `@vercel/sandbox`（需要Vercel账户）
2. 在数据库或前端存储 `sandboxId`
3. 每次请求时重用已有沙盒

### 决策
**暂时不实现持久化**，接受每次对话沙盒重置的行为。

**原因**：
1. 需要额外的Vercel账户配置
2. 需要修改数据库schema存储sandboxId
3. 当前功能已满足基本需求

### 未来可扩展
如果需要持久化支持，可以：
1. 在 `conversations` 表添加 `sandbox_id` 字段
2. 首次创建沙盒时存储ID
3. 后续请求时重用沙盒
